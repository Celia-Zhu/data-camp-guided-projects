---
title: "PPHA 30535 Skills Problem Set 1"
author: "Xiling Zhu 12244990"
date: "04/10/2020"
output:
  html_document:
    number_sections: TRUE
---

> Front matter

This submission is my work alone and complies with the 30535 integrity policy.

Add your initials to indicate your agreement: **X.Z**

Add your collaborators: **Yisi Jing**

Late coins used this pset: 0. Late coins left: 4. 
<!--You may use up to two for a given assignment.)-->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, error = FALSE)
```
***

# Setup

## Installation
10. Install these packages
```{r Install packages}

# Install packages
list_of_packages <- c("tidyverse", "rmarkdown", "econometrics", "AEC", "AED") 
# The last three "packages" are random names I made up. 
# I used them to test if the code in the next chunk returns the proper message. 

# install.packages("list_of_packages")
```

11. Run a line of code which tests the packages are installed 
```{r Test if the packages are successfully installed}
# Adapted from a post from Axeman on Feb 15 2017 and Matthew on Jun 20 2017 on Stackoverflow
#(Source: https://stackoverflow.com/a/19871106 and https://stackoverflow.com/a/44660688)

message<-function(package) {
    req<-(lapply(package,require,character.only=TRUE))
    miss<-package[req==FALSE]
    n<-length(miss)
     if(n>0){
        libsmsg<-if(n>2) paste(paste(miss[1:(n-1)],collapse=", "),",",sep="") else need[1]
        if(n>1){
            libsmsg<-paste(libsmsg," and ", miss[n],sep="")
        }
        }
        libsmsg_final<-paste("The following packages could not be found: ",libsmsg, collapse="")
    print(libsmsg_final)
}

dynamic_require <- function(package){
  if(eval(parse(text=paste("require(",package,")")))) return ("All packages successfully installed")
  else message(package)
}

dynamic_require(list_of_packages)
```

12. My Github ID is CeliaZhu.

# R for Data Science Exercises
## First Steps
```{r Load packages and have a glimpse on the dataset}
pkg_list <- c("tidyverse", "ggplot2")
lapply(pkg_list, require, character.only = TRUE)
```

1. How many rows are in mpg? How many columns? What do the rows represent? How about the columns?

    *There are 234 rows, and 11 columns in the mpg data set.*
 
    *Columns represent variables and their values, and rows represent observations.*
  
    *The 11 variables are:*
  
 | Variable Names | Meaning                        |
| -------------- | ------------------------------ |
| Manufacture    | Manufacturer name              |
| model          | model name                     |
| displ          | engine displacement, in litres |
| year           | year of manufacture            |
| cyl            | number of cylinders            |
| trans          | type of transmission           |
| drv            | the type of drive train        |
| cty            | city miles per gallon          |
| hwy            | highway miles per gallon       |
| fl             | fuel type                      |
| class          | "type" of car                  |
| fl             | fuel type                      |
| class          | "type" of car                  |
```{r}
nrow(mpg)
ncol(mpg)
```

2. Make a scatter plot of hwy vs. cyl
```{r}
# Scatterplot of hwy vs cyl
ggplot(mpg,aes(x = hwy, y = cyl)) +
  geom_point()
```

3. What does the drv variable describe?

    *drv variable describes the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = four-wheel drive.*
```{r}
?mpg
```

4. What happens if you make a scatterplot of class vs drv? Why is the plot not useful?

    *The scatterplot is not useful becuase: 1) scatterplot is most useful to explore the relationship bewteen two continous variables, but here both class and drv are categorical; 2) in default scatterplot, one dot might represent multiple observations, becuase one dot may lay on top of another dot. How class changes as drv changes cannot be truthfully visualized.*

    *To fix the 2 problems mentioned above, I used `geom_count()` instead.*
```{r}
# Scatterplot of class vs drv
ggplot(mpg,aes(x = class, y = drv)) +
  geom_point()

ggplot(mpg,aes(x = class, y = drv)) +
  geom_count()
```

## Grammar of graphics: Mapping data to aesthetics
1. Run ?mpg to pull up the documentation for the dataset. Run print(mpg) to see the first 10 rows of the tibble. Notice the tibble header in the console includes the variable type (e.g. `<chr>` is character). Describe how the `<chr>`, `<int>` and `<dbl>` variable types map to whether a variable is categorical versus continuous.

    *`<chr>` maps to categorical. `<int>` and `<dbl>` map to continuous. An example would be the first graph of 2.2 #2, where ggplot treated year `<int>` as a continuous variable and mapped sequential colors to it.* 

```{r}
?mpg
print(mpg[1:10,])
```

2. Graph the following two scatter plots. Why are the two graphs different? Which graph is a better representation of the data?

    *Graph 2 is a better representation because 1): in graph 1 we did not factorize year, making ggplot treat it as a continuous variable. The consequence is that 4 of the years displayed in the legend do not exist in the dataset at all (2000, 2002, 2004, 2006). And the year that exists (1998) is not displayed in the legend. 2) In graph 2 we change year into a categorical variable, therefore ggplot truthfully visualize the years in our dataset and maps qualitative colors to it. There are less noise in graph 2; hence it's a better representation.*
```{r}
# Graph 1
ggplot(data = mpg)+
  geom_point(mapping = aes(x = hwy, y = cty, color = year))

"2000" %in% mpg$year
"2002" %in% mpg$year
"2004" %in% mpg$year
"2006" %in% mpg$year
"2008" %in% mpg$year

# Graph 2
ggplot(data = mpg)+
  geom_point(mapping = aes(x = hwy, y = cty, color = as.character(year)))
```

3. What happens if you map an aesthetic to something other than a variable name, like aes(color = displ < 5)

    *In this example, R evaluates the logical statement and returns a Boolean variable. ggplot maps color aesthetics to that Boolean variable.*
```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = hwy, y = cty, color = displ < 5))
```

4. Common bugs: Whatâ€™s gone wrong with this code? Fix the code so the points are blue.
 
    *Including `'color = "blue"` in `aes()` argument, we are mapping a variable which takes "blue" as its value to the color scale. However, 1) there is no such variable in our dataset; and 2) we intend to change the visual attributes of the points, not to change the mapping of variables. Therefore we should specify the color attributes outside the `aes()` argument.* 
```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))

# Fix:
ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```


## Grammar of graphics: Facets

1. Make the follow plots. How does facet_grid() decide the layout of the grid?

    *`facet_grid()` forms a matrix of panels defined by row and column faceting variables.*
 
    *`facet_grid(cols = vars(x))`: display the faceting groups, which are defined by variable x, on the columns.*
 
    *`facet_grid(rows = vars(y))`: display the faceting groups, which are defined by variable y, on the rows*
 
    *`facet_grid(cols = vars(x), rows = vars(y))`: display the x-faceting group on columns of the matrix, and y-faceting group on the rows.*
 
    *(From R Documentation: facet_grid{ggplot2})*
```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy))+
  facet_grid(cols = vars(drv))

ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy))+
  facet_grid(rows = vars(year))

ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy))+
  facet_grid(cols = vars(drv), rows = vars(year))
```

2. What happens if you facet on a continuous varible? Provide an example.

    *A continuous variable takes many values so the grids are too small to be informative.*
```{r}
str(mpg)

ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy))+
  facet_grid(cols = vars(displ))
```

3. Reproduce the graph.
```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = class, y = hwy, col = class))+
  facet_grid(rows = vars(year))
```
 
4. The x-axis labels for class on this plot are really hard to read! Can you rotate the labels by 45 degrees so that they don't overlap one another?
```{r}
# Adapted from a post from  Jonathan Chang Aug 25 2009 on Stackoverflow
#(Source: https://stackoverflow.com/a/1331400 retrevied on Apr 06 2020)
ggplot(data = mpg)+
  geom_point(mapping = aes(x = class, y = hwy, col = class))+
  facet_grid(rows = vars(year))+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

5. Reproduce the graph. Why are so many manufacturers missing? 

    *The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate. But here we have 15 values for the manufactures.*
```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy, shape = manufacturer))+
  facet_grid(rows = vars(year), cols = vars(drv))
```

## Grammar of graphics: geoms

1. Waht geom would you use to draw a line chart? A boxplot? A histogram? An area chart?

    _*Line chart: `geom_line()`_
    _*Boxplot: `geom_box()`_
    _*Histogram: `geom_hisogram()`_
    _*Area chart: `geom_area()`_

2. Will these two graphs look different? Why/why not?

    *These two graphs do not look different. Because if we specify mapping in the ggplot layer, and does not specify different mapping(s) in geom layers, geom would inherit the mapping from ggplot, which is in effect the same as repeating the same mapping in geom layers *
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth(se=FALSE)

ggplot() +
geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy), se = FALSE)
```

3. You are investigating the connection between city gas mileage and car characteristics in your role as a policy analyst for a climate change organization. Write code to make this graph.
```{r}
ggplot(mpg, aes(x = displ, y = cty))+
  geom_point(aes(col = drv))+
  geom_smooth(se = FALSE)
```

4. Your colleague suggests you improve the graph by:
  * make line black
  * make the x- and y-axes labels more informative using + labs()
  * use an informative title to capture the headline finding of your analysis 
  * remove the legend (google might be helpful to learn how)
  
    Make these changes. Are all four changes improvements? Which change made the plot worse and why?

    *Removing the legend doesn't seem like an improvement. It makes the graph less informative because our readers may not know what the colors represent. *
 
    *Adding x- and y-axes labels and adding a title make the visualization more informative and easier to understand. Changing the color of the regression line makes it more contrast from the colored points therefore reduces confusion. *
```{r}
# The code is based on https://www.datanovia.com/en/blog/ggplot-legend-title-position-and-labels/ retrieved on April 06, 2020.
ggplot(mpg, aes(x = displ, y = cty))+
  geom_point(aes(col = drv))+
  geom_smooth(se = FALSE, col = "black")+
  xlab("Engine displacement, in litres")+
  ylab("City miles per gallon")+
  ggtitle("Relationship between engine displacement and city miles per gallon") +
  theme(legend.position = "none")
```


### Grammar of graphics: Statistical transformations 

1. What deos geom_col() do? How is it different from geom_bar?

    *`geom_bar()` makes the height of the bar proportional to the number of cases in each group (or if the weight aesthetic is supplied, the sum of the weights).* 

    *`geom_col()` makes the heights of the bars to represent values in the data.*

    *`geom_bar()` uses `stat_count()` by default: it counts the number of cases at each x position. `geom_col()` uses `stat_identity()`: it leaves the data as is.*

    *(The answer is based on R documentation: Bar charts)*
```{r}
?geom_col
```

2. Plot `ggplot(data = mpg, aes(x = hwy)) + geom_bar()`. Replace the geom with a stat to make the same graph.
```{r}
ggplot(data = mpg, aes(x = hwy))+
  geom_bar()

ggplot(data = mpg, aes(x = hwy))+
  stat_count()
```


3. Which 4 variables does `stat_smooth()` compute? How are these variables displayed on a graph made with `geom_smooth()`? What parameters control its behavior?

+ Four variables and their visualization
   
    *y: predicted value, displayed as the regression line.*

    *ymin: lower pointwise confidence interval around the mean, displayed as the lower bound of the band*

    *ymax: upper pointwise confidence interval around the mean, displayed as the upper bound of the band*

    *se: standard error. Pick a point on the x-axis, find the corresponding ymax and predicted y (whose visualization are are expalined above), then the gap between ymax and predicted y divided by a critical value (which depends on the fitting method) yields to the standard error. Though s.e. is not directly displayed, it's proportional to the band width. The wider the band, the higher the s.e.* 
  
    *(Adapted from https://stats.stackexchange.com/a/49890)*

+ Parameters that control its behavior:*
 
    *method: determines which fitting method should be used. By default: LOESS (Local Polynomial Regression Fitting) if the largest group is less than 1,000 observations, otherwise otherwise GAM (Generalized additive models with integrated smoothness estimation) is used with formula = y ~ s(x, bs = "cs") with method = "REML".*
  
    *formula: formula to use in smoothing function. Determines dependent and independent variables.*
  
    *na.rm: If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.*
  
    *(Based on R Documentation, geom_smooth{ggplot2})*

4. Most geoms and stats come in pairs. Read through the documentation and make a list of 5 pairs. Notice that ggplot syntax helps you to understand when a geom and a stat go together.

    *`geom_smooth()` and `stat_smooth()`*
 
    *`geom_bar()` and `stat_count()`*
 
    *`geom_histogram()` and `stat_bin()`*
 
    *`geom_freqpoly()` and `stat_bin()`*
 
    *`geom_count()` and `stat_sum()`*

5. In our proportion bar chart, we need to set `group = 1`. Why? In other words, what is the problem with the graph? Specifically, what denominator is ggplot using to determine proportions?

    *group="whatever" is a "dummy" grouping to override the default behavior. Here the default is to group by cut and in general is to group by the x variable. The default for geom_bar is to group by the x variable in order to separately count the number of rows in each level of the x variable. For example, here, the default would be for geom_bar to return the number of rows with cut equal to "Fair", "Good", etc.*

    *However, if we want proportions, then we need to consider all levels of cut together. In the second plot, the data are first grouped by cut, so each level of cut is considered separately. The proportion of Fair in Fair is 100%, as is the proportion of Good in Good, etc. group=1 (or group="x", etc.) prevents this, so that the proportions of each level of cut will be relative to all levels of cut.*

    *(The answer is based on https://stackoverflow.com/a/39879232)*

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x = cut, y = ..prop..))

ggplot(data = diamonds)+
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
```

## Grammar of graphics: Positional adjustments
1. What is the problem with this plot? How could you improve it?
 
    *Overplotting: one dot might represent multiple observations, becuase one dot may lay on top of another dot.*
    
    *There are 3 ways to improvement this plot: jitter, `geom_count()`, and add transparency.*
```{r}
ggplot(data = mpg, mapping =aes(x = cty, y = hwy))+
  geom_point()

# Jitter
ggplot(data = mpg, mapping =aes(x = cty, y = hwy))+
  geom_jitter()

# goem_count
ggplot(data = mpg, mapping =aes(x = cty, y = hwy))+
  geom_count()

# Transparency
ggplot(data = mpg, mapping =aes(x = cty, y = hwy))+
  geom_point(alpha = 0.2)
```


2. Compare and contrast `geom_jitter()` with `geom_count()`. Use the vocabulry from the "grammar of graphics" to support your argument.

    *`geom_jitter()` is a shortcut for `geom_point(position = "jitter")`. It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets.*
 
    *`geom_point()` is a variant `geom_point()` that counts the number of observations at each location, then maps the count to point area. It useful when you have discrete data and overplotting.*
 
    *Both `geom_jitter()` and `geom_point()` are based on the scatterplot geometry (`geom_point()`) and they are useful to avoid overplotting. But they are different in the sense that `geom_jitter()` essentially adjusts the position attribute of the scatterplot by adding random variation, but `geom_count()` maps the count of observations at each location to the size of the point.*
 
    *(Based on R Documentation geom_jitter{ggplot2} and geom_count{ggplot2})*
```{r}
?geom_jitter
?geom_count
```

3. What's the default position adjustment for `geom_bar()`? What did we add to the code to change the default behavior of `geom_bar()`?

    *The default position adjustment for `geom_bar()` is "stack".*
```{r}
?geom_bar
ggplot(diamonds, aes(x = cut, y = ..prop.., group = 1))+
  geom_bar()

ggplot(diamonds, aes(x = cut, y = ..prop.., group = 1))+
  geom_bar(position = "stack")

ggplot(diamonds, aes(x = cut, y = ..prop.., group = color))+
  geom_bar(aes(fill = color), position = "dodge")
```

## Grammar of graphics: Coordinate systems

1. What happens when you use `coord_flip()`?

    *Adding coord_flip flips the x- and y- axes.*
```{r}
ggplot(data = mpg, aes(x = cty, y = hwy))+
  geom_point()

ggplot(data = mpg, aes(x = cty, y = hwy))+
  geom_point()+
  coord_flip()
```

2. What does the plot below tell you about the relationship between city and highway mpg? What does `geom_abline()` do? Why is `coord_fixed()` important?

    *Highway mpg positively correlates with city mpg.*

    *geom_abline() adds a reference line to annotate the plot. By default, intercept = 0, slope = 1.* 
    
    *(The answer is based on R documentation of geom_abline and https://stackoverflow.com/a/39197400)*

    *A fixed scale coordinate system forces a specified ratio between the physical representation of data units on the axes; therefore the ratio of data units on the axes would not not be affected by graph resizing, and the relationship between x and y would not be masked by disproportionally resizing the graph.*
 
    *The default, ratio = 1, ensures that one unit on the x-axis is the same length as one unit on the y-axis.* 
 
    *(The answer is based on R documentation coord_fixed{ggplot2})*
```{r}
ggplot(mpg, aes(x = cty, y = hwy))+
  geom_point()

ggplot(mpg, aes(x = cty, y = hwy))+
  geom_point()+
  geom_abline()

?geom_abline


ggplot(mpg, aes(x = cty, y = hwy))+
  geom_point()+
  geom_abline()+
  coord_fixed()

?coord_fixed
```

